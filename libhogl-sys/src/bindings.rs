/* automatically generated by rust-bindgen */

#[repr(i32)]
#[doc = " @brief hogl event modifier, representing if any special keys (ctrl, alt, etc.) were pressed during the event"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hogl_e_modifier {
    HOGL_ENUM_MOD_SHIFT = 0,
    HOGL_ENUM_MOD_CONTROL = 1,
    HOGL_ENUM_MOD_ALT = 2,
    HOGL_ENUM_MOD_SUPER = 3,
    HOGL_ENUM_MOD_CAPS = 4,
    HOGL_ENUM_MOD_NUM = 5,
}
#[repr(i32)]
#[doc = " @brief hogl event action, representing the actual action for key events, REPEAT is keyboard event specific"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hogl_e_action {
    HOGL_ENUM_MOD_DOWN = 0,
    HOGL_ENUM_MOD_UP = 1,
    HOGL_ENUM_MOD_REPEAT = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _hogl_context_impl {
    _unused: [u8; 0],
}
pub type hogl_context_impl = _hogl_context_impl;
#[doc = " @brief Mouse key callback, parameters: user defined pointer, event details"]
pub type hogl_ecb_mkey = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *const hogl_e_mkey),
>;
#[doc = " @brief Mouse move callback, parameters: user defined pointer, event details"]
pub type hogl_ecb_mmove = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *const hogl_e_mmove),
>;
#[doc = " @brief Mouse scroll callback, parameters: user defined pointer, event details"]
pub type hogl_ecb_mscroll = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *const hogl_e_mscroll),
>;
#[doc = " @brief Key callback, parameters: user defined pointer, event details"]
pub type hogl_ecb_key = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *const hogl_e_key),
>;
#[doc = " @brief hogl context structure contains all the needed information for all hogl operations"]
#[doc = " it is used to make sure the library is initialized, keeps track of event loops etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hogl_context {
    #[doc = " @brief Implementation details for the hogl context"]
    pub details: *mut hogl_context_impl,
}
#[test]
fn bindgen_test_layout_hogl_context() {
    assert_eq!(
        ::std::mem::size_of::<hogl_context>(),
        8usize,
        concat!("Size of: ", stringify!(hogl_context))
    );
    assert_eq!(
        ::std::mem::align_of::<hogl_context>(),
        8usize,
        concat!("Alignment of ", stringify!(hogl_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_context>())).details as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_context),
            "::",
            stringify!(details)
        )
    );
}
extern "C" {
    #[doc = " @brief Initializes hogl library, this function should only be called once, calling twice is undefined"]
    #[doc = " behavior"]
    #[doc = " @return hogl_context instance"]
    pub fn hogl_init() -> *mut hogl_context;
}
extern "C" {
    #[doc = " @brief Shuts down the hogl library, this function should only be called once, calling twice is undefined"]
    #[doc = " behavior"]
    #[doc = " @param context hogl context recieved from hogl_init function"]
    pub fn hogl_shutdown(context: *mut *mut hogl_context);
}
#[doc = " @brief hogl window"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hogl_wnd {
    #[doc = " @brief hogl context that was used to create this window"]
    pub context: *mut hogl_context,
    #[doc = " @brief [STATE] Specifies if this window is closed, the value is updated after calling hogl_wnd_state_update function"]
    pub is_closed: ::std::os::raw::c_int,
    #[doc = " @brief Native window of created with the help of GLFW"]
    #[doc = " in reality this is a type erased GLFW window"]
    pub native_window: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_hogl_wnd() {
    assert_eq!(
        ::std::mem::size_of::<hogl_wnd>(),
        24usize,
        concat!("Size of: ", stringify!(hogl_wnd))
    );
    assert_eq!(
        ::std::mem::align_of::<hogl_wnd>(),
        8usize,
        concat!("Alignment of ", stringify!(hogl_wnd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_wnd>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_wnd),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_wnd>())).is_closed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_wnd),
            "::",
            stringify!(is_closed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_wnd>())).native_window as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_wnd),
            "::",
            stringify!(native_window)
        )
    );
}
extern "C" {
    #[doc = " @brief Creates a hogl window"]
    #[doc = " @param context hogl context received from hogl_init function"]
    #[doc = " @return hogl_wnd instance or null if there was an error"]
    pub fn hogl_wnd_create(context: *mut hogl_context) -> *mut hogl_wnd;
}
extern "C" {
    #[doc = " @brief Destroys hogl_wnd"]
    #[doc = " @param wnd Window received from hogl_wnd_create function to destroy"]
    pub fn hogl_wnd_destroy(wnd: *mut *mut hogl_wnd);
}
extern "C" {
    #[doc = " @brief Update window state variables for more info look at hogl_wnd struct"]
    #[doc = " @param wnd hogl window struct"]
    pub fn hogl_wnd_state_update(wnd: *mut hogl_wnd);
}
#[doc = " @brief hogl mouse button event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hogl_e_mkey {
    #[doc = " @brief Button that caused the event"]
    pub button: ::std::os::raw::c_int,
    #[doc = " @brief Event action"]
    pub action: hogl_e_action,
    #[doc = " @brief Modifier for this event for more check hogl_e_modifier"]
    pub modifier: hogl_e_modifier,
    #[doc = " @brief Window where the event originated from"]
    pub window: *mut hogl_wnd,
}
#[test]
fn bindgen_test_layout_hogl_e_mkey() {
    assert_eq!(
        ::std::mem::size_of::<hogl_e_mkey>(),
        24usize,
        concat!("Size of: ", stringify!(hogl_e_mkey))
    );
    assert_eq!(
        ::std::mem::align_of::<hogl_e_mkey>(),
        8usize,
        concat!("Alignment of ", stringify!(hogl_e_mkey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_mkey>())).button as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_mkey),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_mkey>())).action as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_mkey),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_mkey>())).modifier as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_mkey),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_mkey>())).window as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_mkey),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief hogl mouse moved event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hogl_e_mmove {
    #[doc = " @brief Mouse position in the x axis, relative to left edge"]
    pub x: f64,
    #[doc = " @brief MOuse position in the y axis, relative to top edge"]
    pub y: f64,
    #[doc = " @brief Window where the event originated from"]
    pub window: *mut hogl_wnd,
}
#[test]
fn bindgen_test_layout_hogl_e_mmove() {
    assert_eq!(
        ::std::mem::size_of::<hogl_e_mmove>(),
        24usize,
        concat!("Size of: ", stringify!(hogl_e_mmove))
    );
    assert_eq!(
        ::std::mem::align_of::<hogl_e_mmove>(),
        8usize,
        concat!("Alignment of ", stringify!(hogl_e_mmove))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_mmove>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_mmove),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_mmove>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_mmove),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_mmove>())).window as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_mmove),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief hogl mouse scroll event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hogl_e_mscroll {
    #[doc = " @brief X axis offset"]
    pub x: f64,
    #[doc = " @brief Y axis offset"]
    pub y: f64,
    #[doc = " @brief Window where the event originated from"]
    pub window: *mut hogl_wnd,
}
#[test]
fn bindgen_test_layout_hogl_e_mscroll() {
    assert_eq!(
        ::std::mem::size_of::<hogl_e_mscroll>(),
        24usize,
        concat!("Size of: ", stringify!(hogl_e_mscroll))
    );
    assert_eq!(
        ::std::mem::align_of::<hogl_e_mscroll>(),
        8usize,
        concat!("Alignment of ", stringify!(hogl_e_mscroll))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_mscroll>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_mscroll),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_mscroll>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_mscroll),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_mscroll>())).window as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_mscroll),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief hogl keyboard key input event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hogl_e_key {
    #[doc = " @brief Button that caused the event"]
    pub key: ::std::os::raw::c_int,
    #[doc = " @brief Event action"]
    pub action: hogl_e_action,
    #[doc = " @brief Modifier for this event for more check hogl_e_modifier"]
    pub modifier: hogl_e_modifier,
    #[doc = " @brief Window where the event originated from"]
    pub window: *mut hogl_wnd,
}
#[test]
fn bindgen_test_layout_hogl_e_key() {
    assert_eq!(
        ::std::mem::size_of::<hogl_e_key>(),
        24usize,
        concat!("Size of: ", stringify!(hogl_e_key))
    );
    assert_eq!(
        ::std::mem::align_of::<hogl_e_key>(),
        8usize,
        concat!("Alignment of ", stringify!(hogl_e_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_key>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_key),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_key>())).action as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_key),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_key>())).modifier as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_key),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_key>())).window as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_key),
            "::",
            stringify!(window)
        )
    );
}
#[doc = " @brief hogl event bus is used to create an event sink for hogl events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hogl_e_interface {
    #[doc = " @brief User pointer for this interface"]
    pub user_pointer: *mut ::std::os::raw::c_void,
    #[doc = " @brief Integer for specifying if this event interface should receive events or not 1 for yes, 0 for no, default 1"]
    pub active: ::std::os::raw::c_int,
    pub cb_mkey: hogl_ecb_mkey,
    pub cb_mmove: hogl_ecb_mmove,
    pub cb_mscroll: hogl_ecb_mscroll,
    pub cb_key: hogl_ecb_key,
}
#[test]
fn bindgen_test_layout_hogl_e_interface() {
    assert_eq!(
        ::std::mem::size_of::<hogl_e_interface>(),
        48usize,
        concat!("Size of: ", stringify!(hogl_e_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<hogl_e_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(hogl_e_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_interface>())).user_pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_interface),
            "::",
            stringify!(user_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_interface>())).active as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_interface),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_interface>())).cb_mkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_interface),
            "::",
            stringify!(cb_mkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_interface>())).cb_mmove as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_interface),
            "::",
            stringify!(cb_mmove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_interface>())).cb_mscroll as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_interface),
            "::",
            stringify!(cb_mscroll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hogl_e_interface>())).cb_key as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hogl_e_interface),
            "::",
            stringify!(cb_key)
        )
    );
}
extern "C" {
    #[doc = " @brief hogl internal function used to bind hogl window to native input API"]
    #[doc = " @param context valid hogl window"]
    pub fn hogl_input_bind_window(window: *mut hogl_wnd);
}
extern "C" {
    #[doc = " @brief Checks for input since the last time this was called"]
    #[doc = " @param context hogl context"]
    pub fn hogl_input_update(context: *mut hogl_context);
}
extern "C" {
    #[doc = " @brief Creates a new hogl event interface, interface are automatically freed upon hogl shutdown, by default the interface is active"]
    #[doc = " @return hogl event interface pointer"]
    pub fn hogl_input_new_interface(context: *mut hogl_context) -> *mut hogl_e_interface;
}
